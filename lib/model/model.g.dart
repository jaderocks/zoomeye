// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Additive.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Additive TABLE
class TableAdditive extends SqfEntityTableBase {
  TableAdditive() {
    // declare properties of EntityTable
    tableName = 'additive';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('serial_no', DbType.text),
      SqfEntityFieldBase('category', DbType.text),
      SqfEntityFieldBase('max', DbType.text),
      SqfEntityFieldBase('note', DbType.text),
      SqfEntityFieldBase('isActive', DbType.bool, defaultValue: true),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAdditive();
  }
}

// Enzyme TABLE
class TableEnzyme extends SqfEntityTableBase {
  TableEnzyme() {
    // declare properties of EntityTable
    tableName = 'enzyme';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('cn_name', DbType.text),
      SqfEntityFieldBase('en_name', DbType.text),
      SqfEntityFieldBase('source', DbType.text),
      SqfEntityFieldBase('note', DbType.text),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableEnzyme();
  }
}

// Processing TABLE
class TableProcessing extends SqfEntityTableBase {
  TableProcessing() {
    // declare properties of EntityTable
    tableName = 'processing';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('cn_name', DbType.text),
      SqfEntityFieldBase('en_name', DbType.text),
      SqfEntityFieldBase('function', DbType.text),
      SqfEntityFieldBase('scope', DbType.text),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProcessing();
  }
}

// Spice TABLE
class TableSpice extends SqfEntityTableBase {
  TableSpice() {
    // declare properties of EntityTable
    tableName = 'spices';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('type', DbType.text),
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('dateCreated', DbType.datetime,
          defaultValue: DateTime.now(), minValue: DateTime.parse('1900-01-01')),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSpice();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class FoodModel extends SqfEntityModelProvider {
  FoodModel() {
    databaseName = foodModel.databaseName;
    password = foodModel.password;
    dbVersion = foodModel.dbVersion;
    preSaveAction = foodModel.preSaveAction;
    logFunction = foodModel.logFunction;
    databaseTables = [
      TableAdditive.getInstance,
      TableEnzyme.getInstance,
      TableProcessing.getInstance,
      TableSpice.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = foodModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = foodModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};
    controllers['additive'] = AdditiveController.getController;

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Additive
class Additive extends TableBase {
  Additive(
      {this.id,
      this.name,
      this.serial_no,
      this.category,
      this.max,
      this.note,
      this.isActive,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Additive.withFields(this.name, this.serial_no, this.category, this.max,
      this.note, this.isActive, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  Additive.withId(this.id, this.name, this.serial_no, this.category, this.max,
      this.note, this.isActive, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Additive.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['serial_no'] != null) {
      serial_no = o['serial_no'].toString();
    }
    if (o['category'] != null) {
      category = o['category'].toString();
    }
    if (o['max'] != null) {
      max = o['max'].toString();
    }
    if (o['note'] != null) {
      note = o['note'].toString();
    }
    if (o['isActive'] != null) {
      isActive =
          o['isActive'].toString() == '1' || o['isActive'].toString() == 'true';
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (Additive)
  int? id;
  String? name;
  String? serial_no;
  String? category;
  String? max;
  String? note;
  bool? isActive;
  DateTime? dateCreated;
  bool? isDeleted;

  // end FIELDS (Additive)

  static const bool _softDeleteActivated = true;
  AdditiveManager? __mnAdditive;

  AdditiveManager get _mnAdditive {
    return __mnAdditive = __mnAdditive ?? AdditiveManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (serial_no != null || !forView) {
      map['serial_no'] = serial_no;
    }
    if (category != null || !forView) {
      map['category'] = category;
    }
    if (max != null || !forView) {
      map['max'] = max;
    }
    if (note != null || !forView) {
      map['note'] = note;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    } else if (isActive != null || !forView) {
      map['isActive'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (serial_no != null || !forView) {
      map['serial_no'] = serial_no;
    }
    if (category != null || !forView) {
      map['category'] = category;
    }
    if (max != null || !forView) {
      map['max'] = max;
    }
    if (note != null || !forView) {
      map['note'] = note;
    }
    if (isActive != null) {
      map['isActive'] = forQuery ? (isActive! ? 1 : 0) : isActive;
    } else if (isActive != null || !forView) {
      map['isActive'] = null;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Additive]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Additive]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      name,
      serial_no,
      category,
      max,
      note,
      isActive,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      serial_no,
      category,
      max,
      note,
      isActive,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Additive>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Additive.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Additive>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Additive>[];
    try {
      objList = list
          .map((additive) => Additive.fromMap(additive as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Additive.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Additive>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Additive> objList = <Additive>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Additive.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Additive by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Additive] if exist, otherwise returns null
  Future<Additive?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Additive? obj;
    final data = await _mnAdditive.getById([id]);
    if (data.length != 0) {
      obj = Additive.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Additive) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnAdditive.insert(this, ignoreBatch);
    } else {
      await _mnAdditive.update(this);
    }

    return id;
  }

  /// Saves the (Additive) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnAdditive.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAdditive.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Additive. Returns a new Primary Key value of Additive

  /// <returns>Returns a new Primary Key value of Additive
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Additive> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Additive> additives,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await FoodModel().batchStart();
    for (final obj in additives) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await FoodModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < additives.length; i++) {
        if (additives[i].id == null) {
          additives[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnAdditive.rawInsert(
          'INSERT OR REPLACE INTO additive (id, name, serial_no, category, max, note, isActive, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            id,
            name,
            serial_no,
            category,
            max,
            note,
            isActive,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Additive id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Additive id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Additive Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Additive>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Additive> additives,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnAdditive.rawInsertAll(
        'INSERT OR REPLACE INTO additive (id, name, serial_no, category, max, note, isActive, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?)',
        additives,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Additive

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Additive invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnAdditive
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnAdditive.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Additive

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Additive invoked (id=$id)');
    {
      return _mnAdditive.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  AdditiveFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AdditiveFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  AdditiveFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AdditiveFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isActive = isActive ?? true;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion additive

// region AdditiveField
class AdditiveField extends FilterBase {
  AdditiveField(AdditiveFilterBuilder additiveFB) : super(additiveFB);

  @override
  AdditiveFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder isNull() {
    return super.isNull() as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as AdditiveFilterBuilder;
  }

  @override
  AdditiveField get not {
    return super.not as AdditiveField;
  }
}
// endregion AdditiveField

// region AdditiveFilterBuilder
class AdditiveFilterBuilder extends ConjunctionBase {
  AdditiveFilterBuilder(Additive obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnAdditive = obj._mnAdditive;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  AdditiveManager? _mnAdditive;

  /// put the sql keyword 'AND'
  @override
  AdditiveFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  AdditiveFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  AdditiveFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  AdditiveFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  AdditiveFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  AdditiveFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  AdditiveFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AdditiveFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AdditiveFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AdditiveFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AdditiveFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  AdditiveField _setField(AdditiveField? field, String colName, DbType dbtype) {
    return AdditiveField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  AdditiveField? _id;
  AdditiveField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  AdditiveField? _name;
  AdditiveField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  AdditiveField? _serial_no;
  AdditiveField get serial_no {
    return _serial_no = _setField(_serial_no, 'serial_no', DbType.text);
  }

  AdditiveField? _category;
  AdditiveField get category {
    return _category = _setField(_category, 'category', DbType.text);
  }

  AdditiveField? _max;
  AdditiveField get max {
    return _max = _setField(_max, 'max', DbType.text);
  }

  AdditiveField? _note;
  AdditiveField get note {
    return _note = _setField(_note, 'note', DbType.text);
  }

  AdditiveField? _isActive;
  AdditiveField get isActive {
    return _isActive = _setField(_isActive, 'isActive', DbType.bool);
  }

  AdditiveField? _dateCreated;
  AdditiveField get dateCreated {
    return _dateCreated =
        _setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  AdditiveField? _isDeleted;
  AdditiveField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Additive> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnAdditive!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnAdditive!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Additive> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Additive bulk invoked');
    return _mnAdditive!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from additive ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnAdditive!.updateBatch(qparams, values);
  }

  /// This method always returns [Additive] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Additive?
  @override
  Future<Additive?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnAdditive!.toList(qparams);
    final data = await objFuture;
    Additive? obj;
    if (data.isNotEmpty) {
      obj = Additive.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Additive]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Additive?
  @override
  Future<Additive> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Additive();
  }

  /// This method returns int. [Additive]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? additiveCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final additivesFuture = await _mnAdditive!.toList(qparams);
    final int count = additivesFuture[0]['CNT'] as int;
    if (additiveCount != null) {
      additiveCount(count);
    }
    return count;
  }

  /// This method returns List<Additive> [Additive]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Additive>
  @override
  Future<List<Additive>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Additive> additivesData = await Additive.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return additivesData;
  }

  /// This method returns Json String [Additive]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Additive]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Additive]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnAdditive!.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<Additive>>
  Future<List<DropdownMenuItem<Additive>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<Additive>> o)?
          dropDownMenu]) async {
    buildParameters();
    final additivesFuture = _mnAdditive!.toList(qparams);

    final data = await additivesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<Additive>> items = []..add(DropdownMenuItem(
        value: Additive(),
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: Additive.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)?
          dropDownMenu]) async {
    buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final additivesFuture = _mnAdditive!.toList(qparams);

    final data = await additivesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('-'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Additive]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM additive WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnAdditive!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Additive]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnAdditive!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Additive.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnAdditive!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AdditiveFilterBuilder

// region AdditiveFields
class AdditiveFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fSerial_no;
  static TableField get serial_no {
    return _fSerial_no = _fSerial_no ??
        SqlSyntax.setField(_fSerial_no, 'serial_no', DbType.text);
  }

  static TableField? _fCategory;
  static TableField get category {
    return _fCategory =
        _fCategory ?? SqlSyntax.setField(_fCategory, 'category', DbType.text);
  }

  static TableField? _fMax;
  static TableField get max {
    return _fMax = _fMax ?? SqlSyntax.setField(_fMax, 'max', DbType.text);
  }

  static TableField? _fNote;
  static TableField get note {
    return _fNote = _fNote ?? SqlSyntax.setField(_fNote, 'note', DbType.text);
  }

  static TableField? _fIsActive;
  static TableField get isActive {
    return _fIsActive =
        _fIsActive ?? SqlSyntax.setField(_fIsActive, 'isActive', DbType.bool);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion AdditiveFields

//region AdditiveManager
class AdditiveManager extends SqfEntityProvider {
  AdditiveManager()
      : super(FoodModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'additive';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion AdditiveManager
// region Enzyme
class Enzyme extends TableBase {
  Enzyme(
      {this.id,
      this.cn_name,
      this.en_name,
      this.source,
      this.note,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Enzyme.withFields(this.id, this.cn_name, this.en_name, this.source, this.note,
      this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  Enzyme.withId(this.id, this.cn_name, this.en_name, this.source, this.note,
      this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Enzyme.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = o['id'].toString();
    if (o['cn_name'] != null) {
      cn_name = o['cn_name'].toString();
    }
    if (o['en_name'] != null) {
      en_name = o['en_name'].toString();
    }
    if (o['source'] != null) {
      source = o['source'].toString();
    }
    if (o['note'] != null) {
      note = o['note'].toString();
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    isSaved = true;
  }
  // FIELDS (Enzyme)
  String? id;
  String? cn_name;
  String? en_name;
  String? source;
  String? note;
  DateTime? dateCreated;
  bool? isDeleted;
  bool? isSaved;
  // end FIELDS (Enzyme)

  static const bool _softDeleteActivated = true;
  EnzymeManager? __mnEnzyme;

  EnzymeManager get _mnEnzyme {
    return __mnEnzyme = __mnEnzyme ?? EnzymeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (cn_name != null || !forView) {
      map['cn_name'] = cn_name;
    }
    if (en_name != null || !forView) {
      map['en_name'] = en_name;
    }
    if (source != null || !forView) {
      map['source'] = source;
    }
    if (note != null || !forView) {
      map['note'] = note;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (cn_name != null || !forView) {
      map['cn_name'] = cn_name;
    }
    if (en_name != null || !forView) {
      map['en_name'] = en_name;
    }
    if (source != null || !forView) {
      map['source'] = source;
    }
    if (note != null || !forView) {
      map['note'] = note;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Enzyme]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Enzyme]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      cn_name,
      en_name,
      source,
      note,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      cn_name,
      en_name,
      source,
      note,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Enzyme>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Enzyme.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Enzyme>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Enzyme>[];
    try {
      objList = list
          .map((enzyme) => Enzyme.fromMap(enzyme as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Enzyme.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Enzyme>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Enzyme> objList = <Enzyme>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Enzyme.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Enzyme by ID if exist, otherwise returns null
  /// Primary Keys: String? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Enzyme] if exist, otherwise returns null
  Future<Enzyme?> getById(String? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Enzyme? obj;
    final data = await _mnEnzyme.getById([id]);
    if (data.length != 0) {
      obj = Enzyme.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Enzyme) object. If the Primary Key (id) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same id
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnEnzyme.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO enzyme (id, cn_name, en_name, source, note, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Enzyme> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Enzyme> enzymes,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await FoodModel().batchStart();
    for (final obj in enzymes) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await FoodModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEnzyme.rawInsert(
          'INSERT OR REPLACE INTO enzyme (id, cn_name, en_name, source, note, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            cn_name,
            en_name,
            source,
            note,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Enzyme id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Enzyme id=$id did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Enzyme Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Enzyme

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Enzyme invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnEnzyme
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnEnzyme.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Enzyme

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Enzyme invoked (id=$id)');
    {
      return _mnEnzyme.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  EnzymeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EnzymeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  EnzymeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EnzymeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion enzyme

// region EnzymeField
class EnzymeField extends FilterBase {
  EnzymeField(EnzymeFilterBuilder enzymeFB) : super(enzymeFB);

  @override
  EnzymeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder isNull() {
    return super.isNull() as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as EnzymeFilterBuilder;
  }

  @override
  EnzymeField get not {
    return super.not as EnzymeField;
  }
}
// endregion EnzymeField

// region EnzymeFilterBuilder
class EnzymeFilterBuilder extends ConjunctionBase {
  EnzymeFilterBuilder(Enzyme obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnEnzyme = obj._mnEnzyme;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  EnzymeManager? _mnEnzyme;

  /// put the sql keyword 'AND'
  @override
  EnzymeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  EnzymeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  EnzymeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  EnzymeFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  EnzymeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  EnzymeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  EnzymeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EnzymeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EnzymeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EnzymeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EnzymeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  EnzymeField _setField(EnzymeField? field, String colName, DbType dbtype) {
    return EnzymeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  EnzymeField? _id;
  EnzymeField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  EnzymeField? _cn_name;
  EnzymeField get cn_name {
    return _cn_name = _setField(_cn_name, 'cn_name', DbType.text);
  }

  EnzymeField? _en_name;
  EnzymeField get en_name {
    return _en_name = _setField(_en_name, 'en_name', DbType.text);
  }

  EnzymeField? _source;
  EnzymeField get source {
    return _source = _setField(_source, 'source', DbType.text);
  }

  EnzymeField? _note;
  EnzymeField get note {
    return _note = _setField(_note, 'note', DbType.text);
  }

  EnzymeField? _dateCreated;
  EnzymeField get dateCreated {
    return _dateCreated =
        _setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  EnzymeField? _isDeleted;
  EnzymeField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Enzyme> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnEnzyme!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnEnzyme!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Enzyme> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Enzyme bulk invoked');
    return _mnEnzyme!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from enzyme ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnEnzyme!.updateBatch(qparams, values);
  }

  /// This method always returns [Enzyme] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Enzyme?
  @override
  Future<Enzyme?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnEnzyme!.toList(qparams);
    final data = await objFuture;
    Enzyme? obj;
    if (data.isNotEmpty) {
      obj = Enzyme.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Enzyme]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Enzyme?
  @override
  Future<Enzyme> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Enzyme();
  }

  /// This method returns int. [Enzyme]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? enzymeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final enzymesFuture = await _mnEnzyme!.toList(qparams);
    final int count = enzymesFuture[0]['CNT'] as int;
    if (enzymeCount != null) {
      enzymeCount(count);
    }
    return count;
  }

  /// This method returns List<Enzyme> [Enzyme]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Enzyme>
  @override
  Future<List<Enzyme>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Enzyme> enzymesData = await Enzyme.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return enzymesData;
  }

  /// This method returns Json String [Enzyme]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Enzyme]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Enzyme]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnEnzyme!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Enzyme]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM enzyme WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> idData = <String>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnEnzyme!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as String);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Enzyme]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnEnzyme!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Enzyme.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnEnzyme!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion EnzymeFilterBuilder

// region EnzymeFields
class EnzymeFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fCn_name;
  static TableField get cn_name {
    return _fCn_name =
        _fCn_name ?? SqlSyntax.setField(_fCn_name, 'cn_name', DbType.text);
  }

  static TableField? _fEn_name;
  static TableField get en_name {
    return _fEn_name =
        _fEn_name ?? SqlSyntax.setField(_fEn_name, 'en_name', DbType.text);
  }

  static TableField? _fSource;
  static TableField get source {
    return _fSource =
        _fSource ?? SqlSyntax.setField(_fSource, 'source', DbType.text);
  }

  static TableField? _fNote;
  static TableField get note {
    return _fNote = _fNote ?? SqlSyntax.setField(_fNote, 'note', DbType.text);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion EnzymeFields

//region EnzymeManager
class EnzymeManager extends SqfEntityProvider {
  EnzymeManager()
      : super(FoodModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'enzyme';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion EnzymeManager
// region Processing
class Processing extends TableBase {
  Processing(
      {this.id,
      this.cn_name,
      this.en_name,
      this.function,
      this.scope,
      this.dateCreated,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Processing.withFields(this.id, this.cn_name, this.en_name, this.function,
      this.scope, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  Processing.withId(this.id, this.cn_name, this.en_name, this.function,
      this.scope, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Processing.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = o['id'].toString();
    if (o['cn_name'] != null) {
      cn_name = o['cn_name'].toString();
    }
    if (o['en_name'] != null) {
      en_name = o['en_name'].toString();
    }
    if (o['function'] != null) {
      function = o['function'].toString();
    }
    if (o['scope'] != null) {
      scope = o['scope'].toString();
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    isSaved = true;
  }
  // FIELDS (Processing)
  String? id;
  String? cn_name;
  String? en_name;
  String? function;
  String? scope;
  DateTime? dateCreated;
  bool? isDeleted;
  bool? isSaved;
  // end FIELDS (Processing)

  static const bool _softDeleteActivated = true;
  ProcessingManager? __mnProcessing;

  ProcessingManager get _mnProcessing {
    return __mnProcessing = __mnProcessing ?? ProcessingManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (cn_name != null || !forView) {
      map['cn_name'] = cn_name;
    }
    if (en_name != null || !forView) {
      map['en_name'] = en_name;
    }
    if (function != null || !forView) {
      map['function'] = function;
    }
    if (scope != null || !forView) {
      map['scope'] = scope;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (cn_name != null || !forView) {
      map['cn_name'] = cn_name;
    }
    if (en_name != null || !forView) {
      map['en_name'] = en_name;
    }
    if (function != null || !forView) {
      map['function'] = function;
    }
    if (scope != null || !forView) {
      map['scope'] = scope;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Processing]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Processing]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      cn_name,
      en_name,
      function,
      scope,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      cn_name,
      en_name,
      function,
      scope,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Processing>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Processing.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Processing>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Processing>[];
    try {
      objList = list
          .map((processing) =>
              Processing.fromMap(processing as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Processing.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Processing>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Processing> objList = <Processing>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Processing.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Processing by ID if exist, otherwise returns null
  /// Primary Keys: String? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Processing] if exist, otherwise returns null
  Future<Processing?> getById(String? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Processing? obj;
    final data = await _mnProcessing.getById([id]);
    if (data.length != 0) {
      obj = Processing.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Processing) object. If the Primary Key (id) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same id
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnProcessing.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO processing (id, cn_name, en_name, function, scope, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Processing> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Processing> processings,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await FoodModel().batchStart();
    for (final obj in processings) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await FoodModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProcessing.rawInsert(
          'INSERT OR REPLACE INTO processing (id, cn_name, en_name, function, scope, dateCreated,isDeleted)  VALUES (?,?,?,?,?,?,?)',
          [
            id,
            cn_name,
            en_name,
            function,
            scope,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Processing id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Processing id=$id did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Processing Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Processing

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Processing invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnProcessing
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnProcessing.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Processing

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Processing invoked (id=$id)');
    {
      return _mnProcessing.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  ProcessingFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProcessingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ProcessingFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProcessingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion processing

// region ProcessingField
class ProcessingField extends FilterBase {
  ProcessingField(ProcessingFilterBuilder processingFB) : super(processingFB);

  @override
  ProcessingFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder isNull() {
    return super.isNull() as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ProcessingFilterBuilder;
  }

  @override
  ProcessingField get not {
    return super.not as ProcessingField;
  }
}
// endregion ProcessingField

// region ProcessingFilterBuilder
class ProcessingFilterBuilder extends ConjunctionBase {
  ProcessingFilterBuilder(Processing obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnProcessing = obj._mnProcessing;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ProcessingManager? _mnProcessing;

  /// put the sql keyword 'AND'
  @override
  ProcessingFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ProcessingFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ProcessingFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ProcessingFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ProcessingFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ProcessingFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ProcessingFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProcessingFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProcessingFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProcessingFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProcessingFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ProcessingField _setField(
      ProcessingField? field, String colName, DbType dbtype) {
    return ProcessingField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ProcessingField? _id;
  ProcessingField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ProcessingField? _cn_name;
  ProcessingField get cn_name {
    return _cn_name = _setField(_cn_name, 'cn_name', DbType.text);
  }

  ProcessingField? _en_name;
  ProcessingField get en_name {
    return _en_name = _setField(_en_name, 'en_name', DbType.text);
  }

  ProcessingField? _function;
  ProcessingField get function {
    return _function = _setField(_function, 'function', DbType.text);
  }

  ProcessingField? _scope;
  ProcessingField get scope {
    return _scope = _setField(_scope, 'scope', DbType.text);
  }

  ProcessingField? _dateCreated;
  ProcessingField get dateCreated {
    return _dateCreated =
        _setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  ProcessingField? _isDeleted;
  ProcessingField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Processing> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnProcessing!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnProcessing!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Processing> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Processing bulk invoked');
    return _mnProcessing!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from processing ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnProcessing!.updateBatch(qparams, values);
  }

  /// This method always returns [Processing] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Processing?
  @override
  Future<Processing?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnProcessing!.toList(qparams);
    final data = await objFuture;
    Processing? obj;
    if (data.isNotEmpty) {
      obj = Processing.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Processing]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Processing?
  @override
  Future<Processing> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Processing();
  }

  /// This method returns int. [Processing]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? processingCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final processingsFuture = await _mnProcessing!.toList(qparams);
    final int count = processingsFuture[0]['CNT'] as int;
    if (processingCount != null) {
      processingCount(count);
    }
    return count;
  }

  /// This method returns List<Processing> [Processing]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Processing>
  @override
  Future<List<Processing>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Processing> processingsData = await Processing.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return processingsData;
  }

  /// This method returns Json String [Processing]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Processing]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Processing]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnProcessing!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Processing]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM processing WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> idData = <String>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnProcessing!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as String);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Processing]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnProcessing!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Processing.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnProcessing!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProcessingFilterBuilder

// region ProcessingFields
class ProcessingFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fCn_name;
  static TableField get cn_name {
    return _fCn_name =
        _fCn_name ?? SqlSyntax.setField(_fCn_name, 'cn_name', DbType.text);
  }

  static TableField? _fEn_name;
  static TableField get en_name {
    return _fEn_name =
        _fEn_name ?? SqlSyntax.setField(_fEn_name, 'en_name', DbType.text);
  }

  static TableField? _fFunction;
  static TableField get function {
    return _fFunction =
        _fFunction ?? SqlSyntax.setField(_fFunction, 'function', DbType.text);
  }

  static TableField? _fScope;
  static TableField get scope {
    return _fScope =
        _fScope ?? SqlSyntax.setField(_fScope, 'scope', DbType.text);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ProcessingFields

//region ProcessingManager
class ProcessingManager extends SqfEntityProvider {
  ProcessingManager()
      : super(FoodModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'processing';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ProcessingManager
// region Spice
class Spice extends TableBase {
  Spice({this.id, this.type, this.name, this.dateCreated, this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  Spice.withFields(
      this.id, this.type, this.name, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  Spice.withId(
      this.id, this.type, this.name, this.dateCreated, this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Spice.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = o['id'].toString();
    if (o['type'] != null) {
      type = o['type'].toString();
    }
    if (o['name'] != null) {
      name = o['name'].toString();
    }
    if (o['dateCreated'] != null) {
      dateCreated = int.tryParse(o['dateCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateCreated'].toString())!)
          : DateTime.tryParse(o['dateCreated'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    isSaved = true;
  }
  // FIELDS (Spice)
  String? id;
  String? type;
  String? name;
  DateTime? dateCreated;
  bool? isDeleted;
  bool? isSaved;
  // end FIELDS (Spice)

  static const bool _softDeleteActivated = true;
  SpiceManager? __mnSpice;

  SpiceManager get _mnSpice {
    return __mnSpice = __mnSpice ?? SpiceManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (type != null || !forView) {
      map['type'] = type;
    }
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (type != null || !forView) {
      map['type'] = type;
    }
    if (name != null || !forView) {
      map['name'] = name;
    }
    if (dateCreated != null) {
      map['dateCreated'] = forJson
          ? dateCreated!.toString()
          : forQuery
              ? dateCreated!.millisecondsSinceEpoch
              : dateCreated;
    } else if (dateCreated != null || !forView) {
      map['dateCreated'] = null;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [Spice]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Spice]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      id,
      type,
      name,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      type,
      name,
      dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
      isDeleted
    ];
  }

  static Future<List<Spice>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Spice.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Spice>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Spice>[];
    try {
      objList = list
          .map((spice) => Spice.fromMap(spice as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Spice.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Spice>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Spice> objList = <Spice>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Spice.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Spice by ID if exist, otherwise returns null
  /// Primary Keys: String? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Spice] if exist, otherwise returns null
  Future<Spice?> getById(String? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Spice? obj;
    final data = await _mnSpice.getById([id]);
    if (data.length != 0) {
      obj = Spice.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Spice) object. If the Primary Key (id) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same id
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnSpice.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO spices (id, type, name, dateCreated,isDeleted)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Spice> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Spice> spices,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await FoodModel().batchStart();
    for (final obj in spices) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await FoodModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSpice.rawInsert(
          'INSERT OR REPLACE INTO spices (id, type, name, dateCreated,isDeleted)  VALUES (?,?,?,?,?)',
          [
            id,
            type,
            name,
            dateCreated != null ? dateCreated!.millisecondsSinceEpoch : null,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true, successMessage: 'Spice id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Spice id=$id did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Spice Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Spice

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Spice invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnSpice
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSpice.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover Spice

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover Spice invoked (id=$id)');
    {
      return _mnSpice.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  SpiceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpiceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SpiceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpiceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    dateCreated = dateCreated ?? DateTime.now();
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion spice

// region SpiceField
class SpiceField extends FilterBase {
  SpiceField(SpiceFilterBuilder spiceFB) : super(spiceFB);

  @override
  SpiceFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder isNull() {
    return super.isNull() as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SpiceFilterBuilder;
  }

  @override
  SpiceField get not {
    return super.not as SpiceField;
  }
}
// endregion SpiceField

// region SpiceFilterBuilder
class SpiceFilterBuilder extends ConjunctionBase {
  SpiceFilterBuilder(Spice obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnSpice = obj._mnSpice;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SpiceManager? _mnSpice;

  /// put the sql keyword 'AND'
  @override
  SpiceFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SpiceFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SpiceFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SpiceFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SpiceFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SpiceFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SpiceFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpiceFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpiceFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpiceFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpiceFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SpiceField _setField(SpiceField? field, String colName, DbType dbtype) {
    return SpiceField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SpiceField? _id;
  SpiceField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SpiceField? _type;
  SpiceField get type {
    return _type = _setField(_type, 'type', DbType.text);
  }

  SpiceField? _name;
  SpiceField get name {
    return _name = _setField(_name, 'name', DbType.text);
  }

  SpiceField? _dateCreated;
  SpiceField get dateCreated {
    return _dateCreated =
        _setField(_dateCreated, 'dateCreated', DbType.datetime);
  }

  SpiceField? _isDeleted;
  SpiceField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<Spice> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSpice!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSpice!.delete(qparams);
    }
    return r;
  }

  /// Recover List<Spice> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover Spice bulk invoked');
    return _mnSpice!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from spices ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSpice!.updateBatch(qparams, values);
  }

  /// This method always returns [Spice] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Spice?
  @override
  Future<Spice?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSpice!.toList(qparams);
    final data = await objFuture;
    Spice? obj;
    if (data.isNotEmpty) {
      obj = Spice.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Spice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Spice?
  @override
  Future<Spice> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Spice();
  }

  /// This method returns int. [Spice]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? spiceCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final spicesFuture = await _mnSpice!.toList(qparams);
    final int count = spicesFuture[0]['CNT'] as int;
    if (spiceCount != null) {
      spiceCount(count);
    }
    return count;
  }

  /// This method returns List<Spice> [Spice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Spice>
  @override
  Future<List<Spice>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Spice> spicesData = await Spice.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return spicesData;
  }

  /// This method returns Json String [Spice]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Spice]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Spice]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSpice!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Spice]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM spices WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> idData = <String>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSpice!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as String);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Spice]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSpice!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Spice.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSpice!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SpiceFilterBuilder

// region SpiceFields
class SpiceFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fType;
  static TableField get type {
    return _fType = _fType ?? SqlSyntax.setField(_fType, 'type', DbType.text);
  }

  static TableField? _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField? _fDateCreated;
  static TableField get dateCreated {
    return _fDateCreated = _fDateCreated ??
        SqlSyntax.setField(_fDateCreated, 'dateCreated', DbType.datetime);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion SpiceFields

//region SpiceManager
class SpiceManager extends SqfEntityProvider {
  SpiceManager()
      : super(FoodModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'spices';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SpiceManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await FoodModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await FoodModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await FoodModelSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class FoodModelSequenceManager extends SqfEntityProvider {
  FoodModelSequenceManager() : super(FoodModel());
}
// END OF ENTITIES

// BEGIN CONTROLLERS
// BEGIN CONTROLLER (Additive)

class AdditiveController extends Additive {
  String formListTitleField = 'name';
  String formListSubTitleField = '';
  static SQFViewList getController = SQFViewList(
    AdditiveController(),
    primaryKeyName: 'id',
    useSoftDeleting: true,
  );
  Map<String, String> subMenu() {
    final menu = <String, String>{};

    return menu;
  }

  Future<Widget> gotoEdit(dynamic obj) async {
    return AdditiveAdd(obj == null
        ? Additive()
        : await Additive().getById(obj['id'] as int) ?? Additive());
  }
}
// END CONTROLLER (Additive)

// END OF CONTROLLERS
